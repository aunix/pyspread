
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# generated by wxGlade 0.6 on Sun May 25 23:31:23 2008

# Copyright 2008 Martin Manns
# Distributed under the terms of the GNU General Public License
# generated by wxGlade 0.6 on Mon Mar 17 23:22:49 2008

# --------------------------------------------------------------------
# pyspread is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyspread is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyspread.  If not, see <http://www.gnu.org/licenses/>.
# --------------------------------------------------------------------

import wx

from gui._events import *

from lib.selection import Selection

"""
_grid_cell_actions.py
=======================

Module for cell level main grid level actions.

Provides:
---------
  1. CellActions: Changes to cell code
  
"""


class CellActions(object):
    """Mixin class that supplies Cell code additions, changes and deletion"""

    def set_code(self, key, code):
        """Sets code of cell key, marks grid as changed"""
        
        old_code = self.grid.code_array(key)
        
        if not (old_code is None and not code) and code != old_code:
            # Mark content as changed
            post_command_event(self.main_window, ContentChangedMsg, changed=True)
            
        # Set cell code
        self.grid.code_array[key] = code

    def delete_cell(self,  key):
        """Deletes key cell"""
        
        try:
            self.code_array.pop(key)
        except KeyError:
            pass
    
    def _get_absolute_reference(self, ref_key):
        """Returns absolute reference code for key."""
        
        key_str = u", ".join(map(str, ref_key))
        return u"S[" + key_str + u"]"

    def _get_relative_reference(self, key, ref_key):
        """Returns absolute reference code for key."""
        
        magics = ["X+", "Y+", "Z+"]
        
        # mapper takes magic, key, ref_key to build string
        mapper = lambda val: val[0] + str(val[2] - val[1])
        
        key_str = u", ".join(map(mapper, zip(magics, key, ref_key)))
        
        return u"S[" + key_str + u"]"

    def append_reference_code(self, key, ref_key, ref_type="absolute"):
        """Appends reference code to cell code. 
        
        Replaces existing reference.
        
        Parameters
        ----------
        key: 3-tuple of Integer
        \tKey of cell that gets the reference
        ref_key: 3-tuple of Integer
        \tKey of cell that is referenced
        ref_type: Sting in ["absolute", "relative"]
        \tAn absolute or a relative reference is added
        
        """
        
        if ref_type == "absolute":
            code = self._get_absolute_reference(ref_key)
            
        elif ref_type == "relative":
            code = self._get_relative_reference(key, ref_key)
            
        else:
            raise ValueError, 'ref_type has to be "absolute" or "relative".'
        
        old_code = self.grid.code_array(key)
        
        if old_code is None:
            old_code = u""
        
        if "S" in old_code and old_code[-1] == "]":
            old_code_left, _ = old_code.rsplit("S", 1)
            new_code = old_code_left + code
        else:
            new_code = old_code + code
        
        post_command_event(self.grid.main_window, EntryLineMsg, text=new_code)
    
    def _set_cell_attr(self, selection, table, attr):
        """Sets cell attr for key cell and mark grid content as changed
        
        Parameters
        ----------
        
        attr: dict
        \tContains cell attribute keys
        \tkeys in ["borderwidth_bottom", "borderwidth_right", 
        \t"bordercolor_bottom", "bordercolor_right", 
        \t"bgcolor", "textfont",
        \t"pointsize", "fontweight", "fontstyle", "textcolor", "underline",
        \t"strikethrough", "angle", "column-width", "row-height", 
        \t"vertical_align", "justification", "frozen"]
        
        """
        
        # Mark content as changed
        post_command_event(self.main_window, ContentChangedMsg, changed=True)
        
        if selection is not None:
            self.code_array.cell_attributes.undoable_append( \
                                            (selection, table, attr))
    
    def set_attr(self, attr, value, selection=None):
        """Sets attr of current selection to value"""
        
        if selection is None:
            selection = self.grid.selection
        
        if not selection:
            # Add current cell to selection so that it gets changed
            selection.cells.append(self.cursor[:2])
        
        attrs = {attr: value}
        
        table = self.grid.current_table
        
        # Change model
        
        self.grid.actions._set_cell_attr(selection, table, attrs)
    
    def set_border_attr(self, attr, value, borders):
        """Sets border attribute by adjusting selection to borders"""
        
        selection = self.grid.selection
        # determine selection for core cells and selection for border cells
        # Then apply according to inner and outer
        # A cell is inner iif it is not at the edge of the selection bbox
        
        if "inner" in borders:
            if "top" in borders:
                adj_selection = selection + (-1, 0)
                self.set_attr(attr + "_bottom", value, adj_selection)
            
            if "bottom" in borders:
                self.set_attr(attr + "_bottom", value)
                
            if "left" in borders:
                adj_selection = selection + (0, -1)
                self.set_attr(attr + "_right", value, adj_selection)
            
            if "right" in borders:
                self.set_attr(attr + "_right", value)
            
        else:
            # Adjust selection so that only bounding box edge is in selection
            bbox_tl, bbox_lr = selection.get_bbox()
            if "top" in borders:
                adj_selection = Selection([bbox_tl], [(bbox_tl[0], bbox_lr[1])],
                                          [], [], []) + (-1, 0)
                self.set_attr(attr + "_bottom", value, adj_selection)
            
            if "bottom" in borders:
                adj_selection = Selection([(bbox_lr[0], bbox_tl[1])], [bbox_lr],
                                          [], [], [])
                self.set_attr(attr + "_bottom", value, adj_selection)
                
            if "left" in borders:
                adj_selection = Selection([bbox_tl], [(bbox_lr[0], bbox_tl[1])],
                                          [], [], []) + (0, -1)
                self.set_attr(attr + "_right", value, adj_selection)
            
            if "right" in borders:
                adj_selection = Selection([(bbox_tl[0], bbox_lr[1])], [bbox_lr],
                                          [], [], [])
                self.set_attr(attr + "_right", value, adj_selection)
            

    
    def toggle_attr(self, attr):
        """Toggles an attribute attr for current selection"""
        
        selection = self.grid.selection
        
        # Selection or single cell access?
        
        if selection:
            value = self.get_new_selection_attr_state(selection, attr)
            
        else:
            value = self.get_new_cell_attr_state(self.cursor, attr)
        
        # Set the toggled value
        
        self.set_attr(attr, value)
    
    # Only cell attributes that can be toogled are contained
    
    def change_frozen_attr(self):
        """Changes frozen state of cell if there is no selection"""
        
        # Selections are not supported
        
        if self.grid.selection:
            return
        
        value = self.grid.code_array.cell_attributes[self.cursor]["frozen"]
        
        if value:
            value = False
            
        else:
            res = self.grid.code_array._eval_cell(self.cursor)
            
            if res is None:
                value = " "
            
            else:
                value = str(res)
            
        # Set the new frozen state / code
        
        self.set_attr("frozen", value)
    
    attr_toggle_values = { \
        "fontweight": [wx.NORMAL, wx.BOLD],
        "fontstyle": [wx.NORMAL, wx.ITALIC],
        "underline": [True, False],
        "strikethrough": [True, False],
        "vertical_align": ["top", "middle", "bottom"],
        "justification": ["left", "center", "right"],
        "frozen": [True, False],
        }
    
    def get_new_cell_attr_state(self, key, attr_key):
        """Returns new attr cell state for toggles
        
        Parameters
        ----------
        key: 3-Tuple
        \tCell for which attr toggle shall be returned
        attr_key: Hashable
        \tAttribute key
        
        """
        
        cell_attributes = self.grid.code_array.cell_attributes
        attr_values = self.attr_toggle_values[attr_key]
        
        # Map attr_value to next attr_value
        attr_map = dict(zip(attr_values, attr_values[1:] + attr_values[:1]))
        
        # Return next value from attr_toggle_values value list
        
        return attr_map[cell_attributes[key][attr_key]]
    
    def get_new_selection_attr_state(self, selection, attr_key):
        """Returns new attr selection state for toggles
        
        Parameters
        ----------
        selection: Selection object
        \tSeelction for which attr toggle shall be returned
        attr_key: Hashable
        \tAttribute key
        
        """
        
        cell_attributes = self.grid.code_array.cell_attributes
        attr_values = self.attr_toggle_values[attr_key]
        
        # Map attr_value to next attr_value
        attr_map = dict(zip(attr_values, attr_values[1:] + attr_values[:1]))
        
        selection_attrs = \
            (attr for attr in cell_attributes if attr[0] == selection)
                    
        attrs = {}
        for selection_attr in selection_attrs:
            attrs.update(selection_attr[2])
            
        if attr_key in attrs:
            return attr_map[attrs[attr_key]]
            
        else:
            # Default next value
            return self.attr_toggle_values[attr_key][1]

    def refresh_selected_frozen_cells(self):
        """Refreshes content of frozen cells that are currently selected
        
        If there is no selection, the cell at the cursor is updated.
        
        """
        
        selection = self.grid.selection
        
        # Add cursor to empty selection
        
        if not selection:
            selection.cells.append(self.cursor[:2])
        
        cell_attributes = self.grid.code_array.cell_attributes
        
        for attr_selection, tab, attr_dict in cell_attributes:
            if tab == self.cursor[2] and attr_dict["frozen"]:
                # Only single cells are allowed for freezing
                skey = attr_selection.cells[0]
                if skey in selection:
                    key = tuple(list(skey) + [tab])
                    attr_dict["frozen"] = self.grid.code_array._eval_cell(key)
